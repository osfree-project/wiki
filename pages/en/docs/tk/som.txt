====== somFree Compiler and Emitter Framework ======

====== User's Guide ======

===== Introduction =====

somFree Compiler and Emitter Framework is a free open source binary compatible reimplementation of IBM SOM Compiler and Emitter Framework. It is tries to be as compatible as possible on API and ABI level.

===== Changes =====

Changes from original somFree compiler:

  * Most of internal structures now also present as in old IBM SOM 2.1 NT Toolkit.
  * New emitters:
    * LNK - Open Watcom WLink support.
    * DUMP - displays structures, available to emitter.
    * PAS - Pascal client support.
    * IPAS - Pascal implementation classes support.
  * SOM Compiler library now mostly documented.
  * SOMLINK style functions for most of SOM Compiler library added.
  * Emitters now IBM SOM 2.1 and IBM SOM 3.0 compatible without recompilation.
  * somFree Compiler supports IBM SOM 2.1, IBM SOM 3.0, and somFree 1.0 emitters.
  * somtShowEntry function outputs more info.
  * Undocumented SOMTTypes now documented.
  * SOMIPC now supports IDL 4.2 specification.
  * CORBA C Language Mapping Specification 1.0 now supported by default instead of SOM C Language mapping.
  * Added support of OIDL files

===== SOM Compiler =====

The SOM Compiler is a tool to produce various file formats from Interface Definition Language (IDL) files of Object Interface Definition Language (OIDL) files. SOM Compiler reads IDL or OIDL file and produces an abstract graph tree. Using abstract tree, SOM Compiler generates an object graph tree using classes like SOMTEntryC. After the object graph is ready, SOM Compiler uses classes like SOMTEmitC to produce an output template. Output file generated with help of SOMTTemplateOutputC class.

The SOM Compiler uses DLL-name based loading of classes libraries (other programs can user another approach, like WPS does. WPS uses an Interface Repository to find corresponding class). Most of the SOM Compiler classes libraries it is implementation of corresponding emitter. Emitters can be created with help of Emitter Framework.

SOM Compiler actually is a client program which uses Emitter Framework classes. SOM Compiler is closed-source, but with an open architecture. The only things that couldn't be easily extended are parser, abstract graph builder and object graph builder. Other things can be ''shadowed'' and replaced by our own.

Let's look at SOM Compiler command line syntax to understand how to produce corresponding skeleton code from SOM Compiler template (below is SOM Compiler help screen):

  sc [-C:D:E:I:S:VU:cd:hi:m:prsvw] f1 f2 ...
  Where:
        -C <n>            - size of comment buffer (default: 200000)
        -D <DEFINE>       - same as -D option for cpp.
        -E <var>=<value>  - set environment variable.
        -I <INCLUDE>      - same as -I option for cpp.
        -S <n>            - size of string buffer (default: 200000)
        -U <UNDEFINE>     - same as -U option for cpp.
        -V                - show version number of compiler.
        -c                - ignore all comments.
        -d <dir>          - output directory for each emitted file.
        -h                - this message.
        -i <file>         - use this file name as supplied.
        -m <name[=value]> - add global modifier.
        -p                - shorthand for -D__PRIVATE__.
        -r                - check releaseorder entries exist (default: FALSE).
        -s <string>       - replace SMEMIT variable with <string>
        -u                - update interface repository.
        -v                - verbose debugging mode (default: FALSE).
        -w                - don't display warnings (default: FALSE).
  
  Modifiers:
        addprefixes : adds `functionprefix' to method names in template file
        [no]addstar : [no]add `*' to C bindings for interface references.
              corba : check the source for CORBA compliance.
                csc : force running of OIDL compiler.
         emitappend : append the emitted files at the end of the existing file.
           noheader : don't add a header to the emitted file.
              noint : don't warn about "int" causing portability problems.
             nolock : don't lock the IR during update.
               nopp : don't run the source through the pre-processor.
               notc : don't use typecodes for emit information.
         nouseshort : don't generate short names for types.
          pp=<path> : specify a local pre-processor to use.
           tcconsts : generate CORBA TypeCode constants.
  
  Note: All command-line modifiers can be set in the environment
  by changing them to UPPERCASE and preappending "SM" to them.
  
  Environment Variables:
        SMEMIT=[h;ih;c;xh;xih;xc;def;ir;pdl]
        	: emitters to run (default : h;ih).
        SMINCLUDE=<dir1>[;<dir2>]+
        	: where to search for .idl and .efw files.
        SMKNOWNEXTS=ext[;ext]+
        	: add headers to user written emitters.
        SMTMP=<dir>
        	: directory to hold intermediate files.
        SOMIR=<path>[;<path>]+
        	: list of IRs to search.
  
  Pragmas:
        #pragma somemittypes on          : turn on emission of global types.
        #pragma somemittypes off         : turn off emission of global types.
        #pragma modifier <modifier stm>; : instead of modifier statement.

Now let's explain some command line switches deeper.

First of the most interesting switch is -s. By default SOM Compiler uses SMEMIT environment variable to determine which [[emitter]] to use. Look at emit*.dll files for corresponding [[emitter]]. Using switch -s you can change default logic and select one-time emitter instead of global emitters. In easy situation you need only one emitter (say, C emitter). In complex situations you need use more emitters (say, C, H, DEF and IH emitters). You can create your own emitter to produces, for example, some sort of documentation and other stuff.

Another interesting switch is -m. Using -m you can set and/or unset so named modifiers. Modifiers allow you to change default behaviour of emitter and compiler. As example, by default compiler adds new methods or modifies existent. You can tell compiler just add new text to end of file. Modifiers can control emitters. addstart and noaddstar controls C emitter to add or not add pointer sign (*) to references of objects.

Switch -u adds or updates Interface Repository with new information about class interface. Interface repository filename controlled by SOMIR environment variable. This thing useful to add info for [[Object REXX]] access and other things which uses Interface Repository.

Other switches are like for standard C/C++ preprocessor and not described here.

Now let's play with SOM Compiler. Most often, you need to create interface files for C/C++ client programs. Usually you need to call the SOM Compiler as following:

  sc -sdef somobj.idl
  sc -sh somobj.idl
  
In case of C++ you need to call:

  sc -sdef somobj.idl
  sc -sxh somobj.idl
  
Of course, not very nice to call SOM Compiler so often. And SOM Compiler provides such functionality:

  sc -sdef;h;xh somobj.idl
  
The above command will do exactly as all recent commands.

The above emitters were designed for IBM toolset. Nowadays, developers also use GCC or Open Watcom Compilers. The problem here is that Watcom Linker doesn't support .DEF files, but has its own .LNK linker files. In case of one or two classes no many problems to convert .DEF files to .LNK files manually. But such approach just ugly for MUCH classes. So, one of good solution is write REXX script for DEF→LNK conversion. But SOM Compilers allow extending it by new emitters. So, Open Watcom Linker Emitter was created for such approaches.

At the present time, you can ask article author for current version of Open Watcom Linker Emitter. Open Watcom Emitter source code can be obtained via [http://osfree.svn.sourceforge.net/viewvc/osfree/trunk/OS2/SOM/Frameworks/Emitter/Emitters/Lnk/ osFree repository]. Also, DEF emitter clone [http://osfree.svn.sourceforge.net/viewvc/osfree/trunk/OS2/SOM/Frameworks/Emitter/Emitters/Def/ available] also.

Now let's talk about internals of SOM Compiler. SOM Compiler designed in the way as most of C compilers implemented. It is exists of following parts:

  * SOM Preprocessor
  * IDL Parser
  * Emitter Framework

SOM Compiler first calls SOM Preprocessor. Output of SOM Preprocessor goes to IDL Parser. IDL Parser creates Object tree from IDL source. Object tree, using templates and emitters, stored to file. 

As you see, most of the parts can be extended or replaced by its own implementation. For example, we can reuse CPP instead of SPP. Why not? Just support required command-line switches for compatibility. Also, default emitters can be rewritten. For C and C++ emitter it is not so hard. For other, more structured languages, like Pascal, Modula, etc. emitter creation is more hard work, but it is also possible ([http://osfree.svn.sourceforge.net/viewvc/osfree/trunk/OS2/SOM/Frameworks/Emitter/Emitters/Pas/ btw, author provides development version of Pascal Emitter]).

Actually, we can extend and rewrite SOM Compiler as we want. 

Hope, usage of SOM Compiler will not be problem for most of you. But understanding some details about compiler internals makes life easer.

===== SOM Interface Definition Language =====

Latest IBM SOM 3.0 supports CORBA IDL mostly at level of CORBA 1.1. somFree supports CORBA IDL 4.2 with all extensions found in SOM IDL.

  * Include Directives (optional)
  * Type and Constant Declarations (optional)
  * Exception Declarations (optional)
  * Interface Declarations (optional)
  * Module declaration (optional)

In a [[Introduction to SOM|previous]] article we briefly looked at [[System Object Model|SOM]].
Now we'll try to define our class interface.

Interface Definition Language (IDL) is the core of System Object Model. All classes have definition of its interface via IDL. With help of [[SOM Compiler]] IDL file can be translated to various formats, including various language bindings. For example, to produce C header you can run
 sc -s"h" somcls.idl
to produce DEF file you can run
 sc -s"def" somcls.idl
SOM Compiler uses [[emitter]] to produce corresponding language binding. You can create new bindings emitter using [[Emitter Framework]].

First of all, think about your class. What it must do? Define them in terms of object. Propose attributes and methods of class.

Ok. Imagine, we need class to have access to [[Java]] objects. Let's write a class interface in terms of Interface Definition Language.

 #include <somobj.idl>
 
 interface JavaObject : [[SOMObject]]
 {
   implementation
   {
     somDefaultInit: override;
     // Init Java Virtual Machine (if no current) and create Java object
     somDefaultDestruct: override;
     // Destruct Java object and close Java Virtual Machine (if needed)
   }
 }
As you can see, no many problems. Syntax of IDL too closest to C-like languages. First thing you need is to include definitions of parent classes. In our case it is '''[[SOMObject]]''' definition. Generic Java object doesn't need to have any methods. Only thing '''JavaObject''' will do its check for existence of [[Java Virtual Machine]] and execution of it if required.
On object destruction checks is Java Virtual Machine still required will be done and it will be destroyed if not required. Also same constructor and destructor will call corresponding constructor and destructor of Java object.

Classic IDL file contains definitions like
 interface <class> : <parent_class>
 {
   attribute <type> <name>
 
   <type> <method>(<parameters>)
 }
As I known [http://www.omg.org OMG] IDL doesn't support methods override. SOM IDL has
such feature (and incompatibility with OMG CORBA). This is done via keyword '''implementation'''. To solve problems with other IDL compilers such part must be wrapped to #ifdef structure:

 #include <somobj.idl>
 
 interface JavaObject : [[SOMObject]]
 {
 
   #ifdef __SOMIDL__
   implementation
   {
     somDefaultInit: override;
     // Init Java Virtual Machine (if no current) and create Java object
     somDefaultDestruct: override;
     // Destruct Java object and close Java Virtual Machine (if needed)
   }
   #endif
 }
Such approach well known in C-world, but also have some problems.
For example, IDL of Document Object Model (DOM) (Yes, [http://www.w3.org W3C] DOM uses
same IDL as SOM and CORBA) has attribute '''implementation'''. As result, [[SOM Compiler]] has some problems with IDL compilation.

Ok. Let's stop talking about syntax things (you always can read documentation) and try to create IDL from Java class.

As a first step we'll create SOM class interface for java.lang.Object.
It can be done with help of javah tool.
 javah -jni java.lang.Object

As result you'll have such file:

 /* DO NOT EDIT THIS FILE - it is machine generated */
 #include <jni.h>
 /* Header for class java_lang_Object */
 
 #ifndef _Included_java_lang_Object
 #define _Included_java_lang_Object
 #ifdef __cplusplus
 extern "C" {
 #endif
 /*
  * Class:     java_lang_Object
  * Method:    hashCode
  * Signature: ()I
  */
 JNIEXPORT jint JNICALL Java_java_lang_Object_hashCode
   (JNIEnv *, jobject);
 
 /*
  * Class:     java_lang_Object
  * Method:    notify
  * Signature: ()V
  */
 JNIEXPORT void JNICALL Java_java_lang_Object_notify
   (JNIEnv *, jobject);
 
 /*
  * Class:     java_lang_Object
  * Method:    notifyAll
  * Signature: ()V
  */
 JNIEXPORT void JNICALL Java_java_lang_Object_notifyAll
   (JNIEnv *, jobject);
 
 /*
  * Class:     java_lang_Object
  * Method:    registerNatives
  * Signature: ()V
  */
 JNIEXPORT void JNICALL Java_java_lang_Object_registerNatives
   (JNIEnv *, jclass);
 
 /*
  * Class:     java_lang_Object
  * Method:    wait
  * Signature: (J)V
  */
 JNIEXPORT void JNICALL Java_java_lang_Object_wait
   (JNIEnv *, jobject, jlong);
 
 /*
  * Class:     java_lang_Object
  * Method:    getClass
  * Signature: ()Ljava/lang/Class;
  */
 JNIEXPORT jclass JNICALL Java_java_lang_Object_getClass
   (JNIEnv *, jobject);
 
 /*
  * Class:     java_lang_Object
  * Method:    clone
  * Signature: ()Ljava/lang/Object;
  */
 JNIEXPORT jobject JNICALL Java_java_lang_Object_clone
   (JNIEnv *, jobject);
 
 #ifdef __cplusplus
 }
 #endif
 #endif

So, this header can be used to generate actual class interface
using this script:

 /* REXX - our best dog */
 
 do while lines('java_lang_Object.h')
   s=linein('java_lang_Object.h');
   parse value s with x 'Header for class' name '*/'
   if name\='' then
   do
     classname=strip(name)
     say '#include <JavaObject.idl>'
     say ''
     say 'interface '||classname||' : JavaObject'
     say '{'
   end
   parse value s with x 'Method:' name
   if name\='' then
   do
     /* skip 3 lines */
     s=linein('java_lang_Object.h');
     s=linein('java_lang_Object.h');
     s=linein('java_lang_Object.h');
     s2=linein('java_lang_Object.h');
     interpret("parse value s with 'JNIEXPORT' type 'JNICALL Java_"||classname||"_' name")
     name=strip(name)
     s2=strip(s2)
     parse value s2 with start 'JNIEnv *, jobject' end
     s2=start||end
     parse value s2 with x ', ' y
     if x='(' then s2='('||y
     say '  '||type||name||' '||s2
   end
 end
 say '}'

As result, you'll have following:

 #include <JavaObject.idl>
 
 interface java_lang_Object : JavaObject
 {
    jint hashCode ();
    void notify ();
    void notifyAll ();
    void registerNatives (JNIEnv *, jclass);
    void wait (jlong);
    jclass getClass ();
    jobject clone ();
 } 

Using such approach you can easily make SOM wrappers for all Java classes. Using [[Java_JNI_API]] you can create Java classes and using SOM wrappers you integrate Java code to SOM-based applications. Because SOM API more generic then Java API you can use any available language bindings for development. Also, you can start to extend Java classes by native code with help of SOM engine.

===== SOM Object Interface Definition Language =====

SOM Object Interface Definition Language is a pre-IDL object definition language used before IBM SOM 2.1. Since IBM SOM 2.1 uses CORBA IDL as defined in OMG CORBA 1.1. SOM Object Interface Definition Language (OIDL) is a simple definition language and not recommended to use. SOM Compiler support is only for compatibility with old source code. OIDL support implementation mostly based on [1] and various OIDL source files found on the Web.
OIDL consist of sections set:

  * Include section (optional)
  * Class section (required)
  * Release order section (optional)
  * Parent class section (required)
  * Metaclass section (optional)
  * Data section (optional)
  * Methods section (optional)

====== Programmer's Guide ======

===== Introduction =====

somFree compiler is a tool to convert various interface definition languages to another one or language bindings. somFree compiler frontend is a sc or somc command which control workflow. Because somFree compiler and Emitter Framework modeled after IBM SOM Compiler from here SOM Compiler term will be used. Most of somFree Compiler and Emitter Framework and SOM Compiler and Emitter Framework are same and binary compatible at the documented level. Internal structures of somFree and IBM versions are different.

===== Structure of SOM Compiler and Emitter Framwork =====

SOM Compiler at file level consist of:
  * SOM Compiler frontend
    * sc [Linux]
    * sc.exe [OS/2, Windows]
    *somc.exe [Windows]
  * IDL SOM Pre-processor
    * somcpp [Linux]
    * somcpp.exe [OS/2, Windows]
  * IDL SOM Compiler
    * somipc [Linux]
    * somipc.exe [OS/2, Windows]
  * OIDL SOM Pre-processor
    * spp [Linux]
    * spp.exe [OS/2, Windows]
  * OIDL SOM Compiler
    * somopc [Linux]
    * somopc.exe [OS/2, Windows]
  * SOM Compiler Library
    * somc.so [Linux]
    * somc.dll [OS/2, Windows]
  * SOM Emitter Framework
    * some.so [Linux]
    * some.dll [OS/2, Windows]
  * Emitters
    * emit*.so [Linux]
    * emit*.dll [OS/2, Windows]
  * Public IDL files generator
    * pdl [Linux]
    * pdl.exe [OS/2, Windows]

Currently SOM Compiler provides following emitters:

  * IDL	- IDL Emitter
  * CSC	- OIDL Emitter
  * SC	- OIDL public emitter
  * GEN	- Generic Emitter
  * IR	- Interface Repository Emitter
  * H	- C Binding public header files
  * C	- C Binding implementation template file
  * IH	- C Binding implementation header files
  * XH	- C++ Binding public header files
  * XIH	- C++ Binding implementation header files
  * DEF	- DEF Module Definition file
  * LNK	- LNK Module Linking file
  * HC
  * IMOD - SOM Module initialization emitter
  * MODS - List of class modifiers
  * PDL	- Private IDL emitter
  * PH
  * PSC	- OIDL private emitter
  * UC
  * UXC
  * XPH
  * XTM
  * PAS	- Pascal client library for use of SOM
  * IPAS	- Pascal implementation library to write SOM classes.

Some of Emitters uses Templates such as:

  * cpp.efw
  * ctm.efw
  * gen_c.efc
  * gen_c.efs
  * gen_c.efw
  * gen_cpp.efw
  * gen_def.efw
  * gen_emit.efc
  * gen_emit.efs
  * gen_emit.efw
  * gen_emit.efx
  * gen_idl.efw
  * gen_make.efc
  * gen_make.efs
  * gen_make.efw
  * gen_make.efx
  * gen_mk32.efc
  * gen_mk32.efs
  * gen_mk32.efw
  * gen_mk32.efx
  * gen_mknt.efs
  * gen_mknt.efw
  * gen_mknt.efx
  * gen_nid.efw
  * gen_temp.efw
  * imod.efw

===== Interaction of SOM Compiler components =====

Emitter Framework is a set of classes and SOM Compiler tool. Emitter Framework is used to produce various file formats from the SOM Interface Definition Language files. Emitter Framework classes consist of Emitter classes and Entry classes. Classes can be shadowed. This means a programmer can replace original classes with his own classes. So the SOM Compiler can be highly customized. The only things hard-coded (and closed source) are the IDL file reader and abstract graph builder.

Before starting description of Emitter Framework let's talk about SOM Compiler. We already talked briefly about SOM Compiler. But for emitters we need to know internals of SOM Compiler much better.

Let's start from visible parts of SOM Compiler that requires for its work the following files:

  * sc.exe, somc.dll and somc.msg - Main part of compiler.
  * somcpp.exe - SOM Preprocessor
  * somipc.exe - Goals not known. Seems just execute different emitters
  * emit*.dll - Emitters
  * *.efw - Emitter templates

''sc.exe'' is general part of compiler. Let's try to investigate some internals of sc.exe. First of all we can switch on verbose output and look on it:

  Running shell command:
  somcpp -D__OS2__  -I. -IC:\os2tk45\h -IC:\os2tk45\idl -IC:\os2tk45\som\include \
        -D__SOMIDL_VERSION_1__ -D__SOMIDL__ -C somobj.idl > C:\var\temp\0a500000.CTN
  somipc -mppfile=C:\var\temp\0a500000.CTN -v -e emith -e emitih -e emitctm -e emitc \
        -o somobj somobj.idl
  Loading  emith.
  "SOMObject"
  Unloading  emith.
  Loading  emitih.
  "SOMObject"
  Unloading  emitih.
  Loading  emitctm.
  "SOMObject"
  Unloading  emitctm.
  Loading  emitc.
  "SOMObject"
  Unloading  emitc.
  Removed "C:\var\temp\0a500000.CTN".

Not so many info, but some information here. If we look at SMINCLUDE environment variable:

  SMINCLUDE=.;C:\os2tk45\h;C:\os2tk45\idl;C:\os2tk45\som\include;

then we will see all paths in -I option. 

Considering -D is same as for CPP we can see three symbols defined:
* __OS2__
* __SOMIDL_VERSION_1__  
* __SOMIDL__
somobj.idl it is file we emitted and CTN file is output from preprocessor. The only unknown switch is -C. After small playing we can see it means "leave comments".

So, we can try to replace somcpp with some preprocessor. In [http://www.osfree.org osFree] project we tried to use [http://mcpp.sourceforge.net MCPP] preprocessor. Results is well.

sc.exe reads SMINCLUDE variable and puts its content to -I options of somcpp.exe and redirect output to temporary file.

Ok. Now we can try to detect what is somipc.exe. If we try to execute it with command line pointed above, then we will see:
 Loading  emith.
 "SOMObject"
 Unloading  emith.
 Loading  emitih.
 "SOMObject"
 Unloading  emitih.
 Loading  emitctm.
 "SOMObject"
 Unloading  emitctm.
 Loading  emitc.
 "SOMObject"
 Unloading  emitc.

Heh. Actually, somipc.exe is a real SOM Compiler. Not sc.exe. sc.exe only prepares the input file for the compiler and handles command line and environment variables.

After some playing we can see, somipc returns 0 if all ok and -1 if error.

So, somipc.exe parses preprocessed IDL file and builds Abstract graph. From Abstract graph Object Graph are build. After this somipc.exe calls one by one all emit*.dll files according to -e switches. emit*.dll are set of DLLs with SOM classes.

Drawing here!!

SOM Compiler		IDL SOM Preprocessor		IDL SOM Compiler	Emitter	 Template
			OIDL SOM Preprocessor	OIDL SOM Compiler

Разрисовать по аналогии с со структурой, что в патентах и документации по SOM, но с учетом наличия OIDL и SOMC.

SOM Compiler sc or somc is a frontend which controls basic workflow. Depending on source file extension it call or IDL or OIDL pre-processor and, after preprocessing, IDL or OIDL compiler. IDL or OIDL compiler builds abstract syntax graph using Entry structure. Entry structure contains information about entry type, pointer to object wrapper and all information about object specific attributes.

Note! Entry structure is not documented and differs in somFree and IBM SOM versions.

IDL or OIDL calls required emitters with root Entry structure on emitter entry. Emitter requests root object wrapper and, using or not using template faculty, process all graph using Object Syntax Graph. Object Syntax Graph generates required Entry objects on demand.

Emitter is a subclass of '''[[SOMTEmitC]]''' class. Emitter used to produce output file using template file from object graph of [[the SOM Interface Definition Language]] file. Physically emitter represented as DLL with name EMIT<identificator>.DLL. For C headers emith.dll emitter DLL is used. For C++ headers emitxh.dll emitter DLL is used. Emitter DLL contains only one entry with ordinal 1 and name '''emit'''.

<code>
SOMEXTERN FILE * SOMLINK emit(char *file, Entry * cls, Stab * stab);
</code>

'''emit''' function creates emitter object (from emitter class, which based on '''[[SOMTEmitC]]''') and calls '''somtGenerateSections''' method.

Usually an emitter file can be generated using '''newemit.cmd''' script (can be found at Hobbes in SOMObjects toolkit).

<code>
newemit -C <className> <file_stem>
</code>

To emitter passed Entry object which is root of Object Graph. The root object can be an interface or module class. Processing of such classes slightly different.

Last part of Emitter Framework is template files. Template files allow you to make some control of emitting process. Templates are usual text files with extension *.efw. Here you can modify output for your wish. Not all emitters support templates.

So, now you have some imagination about that Emitter Framework is and how it works.

===== 4. Template faculty =====

Emitters uses template faculty to produce output file. Template file has structure divided by sections. Each section begins from section name ended by colon. Each emitter can use its own section names. Refer to corresponding emitter and Entry classes description for section names information. Here is template file example:

<code>
:copyrightS
This is example template
:templateS
/* Template output example */
<className>
</code>

Core of Template faculty is a Key-Value strings collection represented by SOMStringTableC class. All substitutable to template values stored in SOMStringTableC class instance. On template file process, First of all SOMTEmitC method somtSetPredefinedSymbols sets section names symbols. By default it is following sections: 

| prologSN | prologS |
| baseIncludesPrologSN | baseIncludesPrologS |
| baseIncludesSN | baseIncludesS |
| baseIncludesEpilogSN | baseIncludesEpilogS |
| metaIncludeSN | metaIncludeS |
| classSN | classS |
| metaSN | metaS |
| basePrologSN | basePrologS |
| baseSN | baseS |
| baseEpilogSN | baseEpilogS |
| constantPrologSN | constantPrologS |
| constantSN | constantS |
| constantEpilogSN | constantEpilogS |
| typedefPrologSN | typedefPrologS |
| typedefSN | typedefS |
| typedefEpilogSN | typedefEpilogS |
| structPrologSN | structPrologS |
| structSN | structS |
| structEpilogSN | structEpilogS |
| unionPrologSN | unionPrologS |
| unionSN | unionS |
| unionEpilogSN | unionEpilogS |
| enumPrologSN | enumPrologS |
| enumSN | enumS |
| enumEpilogSN | enumEpilogS |
| attributePrologSN | attributePrologS |
| attributeSN | attributeS |
| attributeEpilogSN | attributeEpilogS |
| interfacePrologSN | interfacePrologS |
| interfaceSN | interfaceS |
| interfaceEpilogSN | interfaceEpilogS |
| modulePrologSN | modulePrologS |
| moduleSN | moduleS |
| moduleEpilogSN | moduleEpilogS |
| passthruPrologSN | passthruPrologS |
| passthruSN | passthruS |
| passthruEpilogSN | passthruEpilogS |
| releaseSN | releaseS |
| dataPrologSN | dataPrologS |
| dataSN | dataS |
| dataEpilogSN | dataEpilogS |
| methodsPrologSN | methodsPrologS |
| methodsSN | methodsS |
| overrideMethodsSN | overrideMethodsS |
| overriddenMethodsSN | overriddenMethodsS |
| inheritedMethodsSN | inheritedMethodsS |
| methodsEpilogSN | methodsEpilogS |
| epilogSN | epilogS |

===== 5. Generic Emitter =====

Generic emitter is a generic template based emitter. It uses simplest template with only one section "template". Main goal of Generic Emitter is to produce Generic framework emitter files. It is used by newemit tool to produce full set of files required to build new emitter.
Добавить описание символов шаблона и описание, какой шаблон за что отвечает.

===== 6. DEF Emitter =====

DEF emitter used to generate definition file for DLL creation using MS LINK. somFree version of emitter uses template file to generate DEF file. Original IBM SOM DEF Emitter uses hard coded generation.
Добавить описание символов шаблона.

===== 7.LNK Emitter =====

LNK emitter used to generate linking file for DLL creation using Watcom WLINK. somFree version of emitter uses template file to generate LNK file. Original IBM SOM DEF Emitter doesn't have such emitter.
Добавить описание символов шаблона.

===== 8. CSC, PSC, SC Emitters =====

CSC emitter used to generate OIDL class definition file (CSC) used in IBM SOM 1.0. somFree version of emitter uses template file to generate CSC file. Original IBM SOM CSC Emitter uses hard coded generation.
Добавить описание символов шаблона.

===== 9. IDL, PDL Emitters =====

IDL emitter used to generate IDL class definition file used in IBM SOM 2.0 and higher. somFree version of emitter uses template file to generate IDL file. Original IBM SOM IDL Emitter uses hard coded generation.
Добавить описание символов шаблона.

===== 10. Developing new emitter =====

somFree Emitter Framework provides templates and libraries for developing emitters compatible with both IBM SOM 2.1 and IBM SOM 3.0 compilers. Because of different ABI (refer Appendix 1 for more information) somFree emitters automatically configures for corresponding API.

===== 13. CORBA C Language mapping =====

somFree Compiler support CORBA C Language Mapping Specification 1.0 [1]. CORBA C Language mapping slightly differ from SOM C Language mapping, used by original IBM SOM 2.1. CORBA C Language mapping is default for somFree Compiler. This chapter provides short description of mapping. For full description refer to [1].

===== 14. SOM C Language mapping =====

SOM C Language mapping is a IBM SOM mapping variant. For some reason (most probably because variable arguments support) IBM SOM not exactly implements C Language Mapping Specification.

====== III. Programmer's reference ======

===== 1. SOM Runtime C library =====

SOM Runtime C library somwm35i is a subset of C runtime library functions found to be used by IBM SOM 3.0 for NT emitters. SOM Runtime C library provided only for support of IBM SOM 3.0 for NT emitters. This is not full featured C library but compatibility layer and must not be used for development. Functions utilize IBM Optlink calling convention. This library required only under Windows NT systems.

List of emulated function and variables.

  * _CRT_init
  * _CRT_term
  * _abort_in_progress
  * _exception_dllinit
  * _matherr
  * fclose
  * _fprintfieee
  * strlen
  * _sprintfieee
  * strcmp
  * strstr
  * _ctype
  * feof
  * fgetc
  * fgets
  * fputs
  * fread
  * fseek
  * fwrite
  * memmove
  * memset
  * remove
  * rename
  * rewind
  * strchr
  * strcpy
  * strlen
  * strncmp
  * strncpy
  * strrchr
  * strtok
  * tolower
  * memcpy
  * strcat
  * getenv
  * _printfieee
  * _sscanfieee
  * exit
  * stderr
  * _putenv
  * _terminate
  * _PrintErrMsg
  * _SysFindFirst
  * _SysFindNext
  * _SysFindClose
  * malloc
  * free
  * strdup
  * strpbrk

===== 2. SOM Compiler library =====

SOM Compiler library somc is a set of helper functions for compiler tasks. Used by IBM SOM emitters. Library provided solely to provide support of IBM emitters. Must not be used to write new code.
==== somtfexists, somtfexistsSL function ====

<code>
SOMEXTERN BOOL somtfexists(char *file);
SOMEXTERN BOOL SOMLINK somtfexistsSL(char *file);
</code>

Check is file exists in paths.

Note: somtfexists version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtsearchFile, somtsearchFileSL function ====

<code>
SOMEXTERN char * somtsearchFile(char *file, char *fullpath, char *env);
SOMEXTERN char * SOMLINK somtsearchFileSL(char *file, char *fullpath, char *env);
</code>

Search path using file and env dirs and return full path if exists.

Note: somtsearchFile version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somttraverseParents, somttraverseParentsSL function ====

<code>
SOMEXTERN int somttraverseParents(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg);
SOMEXTERN int SOMLINK somttraverseParentsSL(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg);
</code>

Note: somttraverseParents version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtloadSL function ====

<code c>
SOMEXTERN EmitFn  SOMLINK somtloadSL(char *fileName, char *functionName, void **modHandle);
</code>

Load emitter <fileName> and return pointer <EmitFn> to emit or emitSL function <functionName> and return handle <modHandle> of loaded module.
This function switches somc to IBM SOM 3.0 ABI if emitSL function found or to IBM SOM 2.1 ABI if emit function found.

==== somtfindBaseEp, somtfindBaseEpSL function ====

<code>
SOMEXTERN Entry * somtfindBaseEp(Entry *ep);
SOMEXTERN Entry * SOMLINK somtfindBaseEpSL(Entry *ep);
</code>

Note: somtfindBaseEp version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtgetType, somtgetTypeSL function ====

<code>
SOMEXTERN Entry * somtgetType(char *name, SOMTTypes type);
SOMEXTERN Entry * SOMLINK somtgetTypeSL(char *name, SOMTTypes type);
</code>

Note: somtGetType version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtokfopen, somtokfopenSL function ====

<code>
SOMEXTERN FILE * somtokfopen(char *path, char *mode);
SOMEXTERN FILE * SOMLINK somtokfopenSL(char *path, char *mode);
</code>

Same as C fopen function.

Note: somtokfopen version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtokrename, somtokrenameSL function ====

<code>
SOMEXTERN int somtokrename(const char*, const char *);
SOMEXTERN int SOMLINK somtokrenameSL(const char*, const char *);
</code>

Note: somtokrename version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtopenEmitFile, somtopenEmitFileSL function ====

<code>
SOMEXTERN FILE * somtopenEmitFile(char *file, char *ext);
SOMEXTERN FILE * SOMLINK somtopenEmitFileSL(char *file, char *ext);
</code>

Note: somtopenEmitFile version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtisDbcs, somtisDbcsSL function ====

<code>
SOMEXTERN BOOL somtisDbcs(int c);
SOMEXTERN BOOL SOMLINK somtisDbcsSL(int c);
</code>

Note: somtisDbcs version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtremoveExt, somtremoveExtSL function ====

<code>
SOMEXTERN boolean somtremoveExt(char *name, char *ext, char *buf);
SOMEXTERN boolean SOMLINK somtremoveExt(char *name, char *ext, char *buf);
</code>

Remove extension from<name> and return to <buf>

Note: somtremoveExt version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtaddExt, somtaddExtSL function ====

<code>
SOMEXTERN char * somtaddExt(char *name, char *ext, char *buf);
SOMEXTERN char * SOMLINK somtaddExtSL(char *name, char *ext, char *buf);
</code>

Add <ext> extension to <name> filestem and return result in <buf>

Note: somtaddExt version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtarrayToPtr, somtarrayToPtrSL function ====

<code>
SOMEXTERN char * somtarrayToPtr(Entry *ep, char *stars, char *buf);
SOMEXTERN char * SOMLINK somtarrayToPtrSL(Entry *ep, char *stars, char *buf);
</code>

Note: somtarrayToPtr version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtattNormalise, somtattNormaliseSL function ====

<code>
SOMEXTERN char * somtattNormalise(char *name, char *buf);
SOMEXTERN char * SOMLINK somtattNormaliseSL(char *name, char *buf);
</code>

Note: somtattNormalise version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink. 
==== somtbasename, somtbasenameSL function ====

<code>
SOMEXTERN char * somtbasenameSL(char *path);
SOMEXTERN char * SOMLINK somtbasenameSL(char *path);
</code>

Return filename without path.

Note: somtbasename version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtctos, somtctosSL function ====

<code>
SOMEXTERN char * somtctos(Const *con, char *buf);
SOMEXTERN char * SOMLINK somtctosSL(Const *con, char *buf);
</code>

Note: somtctos version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtdbcsPostincr, somtdbcsPostincrSL function ====

<code>
SOMEXTERN char * somtdbcsPostincr(char **p);
SOMEXTERN char * SOMLINK somtdbcsPostincrSL(char **p);
</code>

Note: somtdbcsPostincr version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtdbcsPreincr, somtdbcsPreincrSL function ====

<code>
SOMEXTERN char * somtdbcsPreincr(char **p);
SOMEXTERN char * SOMLINK somtdbcsPreincrSL(char **p);
</code>

Note: somtdbcsPreincr version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtdbcsStrchr, somtdbcsStrchrSL function ====

<code>
SOMEXTERN char * somtdbcsStrchr(char *s, int c);
SOMEXTERN char * SOMLINK somtdbcsStrchrSL(char *s, int c);
</code>

==== somtdbcsStrrchr, somtdbcsStrrchrsL function ====


==== somtdbcsStrstr, somtdbcsStrstrSL function ====


==== somteptotype, somteptotypeSL function ====


==== somtgetDesc, somtgetDescSL function ====


==== somtgetVersion, somtgetVersionSL function ====


==== somtgetgatt, somtgetgattSL function ====


==== somtnextword, somtnextwordSL function ====


==== somtnormaliseDesc, somtnormaliseDescSL function ====


==== somtsatos, somtsatosSL function ====


==== somtsearchFile, somtsearchFileSL function ====

Note: somtsearchFile version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtskipws, somtskipwsSL function ====


==== somtstringFmt, somtstringFmtSL function ====

<code>
SOMEXTERN char * somtstringFmtSL(char *fmt, ...)
SOMEXTERN char * SOMLINK somtstringFmtSL(char *fmt, ...)
</code>

Allocate buffer for string, format it using <fmt> and return pointer to buffer.

Note: somtstringFmt version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somttype, somttypeSL function ====

<code>
SOMEXTERN char * somttype(SOMTType type);
SOMEXTERN char * SOMLINK somttypeSL(SOMTType type);
</code>
Return string representation of type of Entry structure except special case SOMTEmitterBeginE and SOMTEmitterEndE types.

Note: somttype version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

Warning: Depricated. Use somtEntryTypeName instead.

==== somtuniqFmt, somtuniqFmtSL function ====

<code>
SOMEXTERN char * somtuniqFmt(MemBuf *membuf, char *fmt, ...)
SOMEXTERN char * SOMLINKL somtuniqFmtSL(MemBuf *membuf, char *fmt, ...)
</code>

Return unique formatted string.

Note: somtuniqFmt version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.
==== somtargFlag, somtargFlagSL function ====


==== somtattjoin, somtattjoinSL function ====


==== somtdbcsLastChar, somtdbcsLastCharSL function ====


==== somtdbcsScan, somtdbcsScanSL function ====


==== somtdiskFull, somtdiskFullSL function ====


==== somtfclose, somtfcloseSL function ====

<code>
SOMEXTERN int somtfclose(FILE *fp);
SOMEXTERN int SOMLINK somtfcloseSL(FILE *fp);
</code>

Same as C fclose function.

Note: somtfclose version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtisparent, somtisparentSL function ====


==== somtmget, somtmgetSL function ====


==== somtmopen, somtmopenSL function ====


==== somtmprintf, somtmprintfSL function ====


==== somtokremove, somtokremoveSL function ====

<code>
SOMEXTERN int somtokremove(char *file);
SOMEXTERN int SOMLINK somtokremoveSL(char *file);
</code>

Alias of C remove function.

Note: somtokremove version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtunload, somtunloadSL function ====


==== somtwriteaccess, somtwriteaccessSL function ====


==== somtsmalloc, somtsmallocSL function ====

<code>
SOMEXTERN void * somtsmalloc(size_t nbytes, BYTE clear);
SOMEXTERN void * SOMLINK somtsmallocSL(size_t nbytes, BYTE clear);
</code>

Allocate <nbytes> of memory and fill it by zeroes if <clear> flag is set.

Note: somtsmalloc version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtaddGAtt, somtaddGAttSL function ====


==== somtcalcFileName, somtcalcFileNameSL function ====


==== somtcleanFilesFatal, somtcleanFilesFatalSL function ====

<code>
SOMEXTERN void  somtcleanFilesFatal(int status);
SOMEXTERN void  SOMLINK somtcleanFilesFatalSL(int status);
</code>

Delete temporary files (if emitted file opened)  and exit.

Note: somtcleanFilesFatal version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtemitTypes, somtemitTypesSL function ====


==== somterror, somterrorSL function ====


==== somtfatal, somtfatalSL function ====


==== somtinternal, somtinternalSL function ====


==== somtmclose, somtmcloseSL function ====


==== somtmsg, somtmsgSL function ====


==== somtreadDescFile, somtreadDescFileSL function ====


==== somtsetDefaultDesc, somtsetDefaultDescSL function ====


==== somtsetEmitSignals, somtsetEmitSignalsSL function ====


==== somtsetTypeDefn, somtsetTypeDefnSL function ====


==== somtshowVersion, somtshowVersionSL function ====


==== somtsmfree, somtsmfreeSL function ====


==== somtunsetEmitSignals, somtunsetEmitSignalsSL function ====


==== somtwarn, somtwarnSL function ====


==== somtuppercase, somtuppercaseSL function ====

<code>
SOMEXTERN char * somtuppercase(char *s, char *buf);
SOMEXTERN char * SOMLINK somtuppercaseSL(char *s, char *buf);
</code>

Convert <s> to upper case and return to <buf>.

Note: somtuppercase version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtlowercase, somtlowercaseSL function ====

<code>
SOMEXTERN char * somtlowercase(char *s, char *buf);
SOMEXTERN char * SOMLINK somtlowercase(char *s, char *buf)
</code>

Convert <s> to lower case and return to <buf>.

Note: somtlowercase version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtdbcsuppercase, somtdbcsuppercaseSL function ====


==== somtdbcslowercase, somtdbcslowercaseSL function ====


==== somtresetEmitSignals, somtresetEmitSignalsSL function ====


==== somtsizeofEntry, somtsizeofEntrySL function ====

<code>
SOMEXTERN size_t somtsizeofEntry(SOMTTypes type);
SOMEXTERN size_t SOMLINK somtsizeofEntrySL(SOMTTypes type);
</code>

Return size of Entry structure for <type> of entry;

Note: somtsizeofEntry version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

Mapping of type to Entry.u type and nameis following:

^ Entry type ^ union struct ^ union name ^
| SOMTClassE | Class | c |
| SOMTMetaE | Meta | mt |
| SOMTBaseE | Parent | p |
| SOMTPassthruE | Passthru | pt |
| SOMTNewMethodE | Method_OR_Data | m |
| SOMTOverrideMethodE | Method_OR_Data | m |
| SOMTOverriddenMethodE | Method_OR_Data | m |
| SOMTDataE | Method_OR_Data | m |
| SOMTArgumentE | Method_OR_Data | m |
| SOMTTypedefBE | Method_OR_Data | m |
| SOMTVoidPtrBE | Method_OR_Data | m |
| SOMTStructE | Struct | struc |
| SOMTTyDclE | Typedef | ty |
| SOMTTypedefE | Typedef | ty |
| SOMTUnionE | Union | un |
| SOMTUnionSE | Union | un |
| SOMTEnumE | Enumerator | enumerator |
| SOMTConstE | Const | con |
| SOMTAttE | Att | att |
| SOMTSequenceE | Sequence | seq |
| SOMTSequenceTDE | Sequence | seq |
| SOMTStringE | String | str |
| SOMTEnumBE | EnumName | enumN |
| SOMTModuleE | Module | mod |

==== somtepname, somtepnameSL function ====

Note: somtgetenname version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtgenSeqName, somtgenSeqNameSL function ====


==== somtmrifatal, somtmrifatalSL function ====


==== somtmriinternal, somtmriinternalSL function ====


==== somtmrierror, somtmrierrorSL function ====


==== somtmrimsg, somtmrimsgSL function ====


==== somtmriwarn, somtmriwarnSL function ====


==== somtsetInternalMessages, somtsetInternalMessagesSL function ====


==== somtisvoid, somtisvoidSL function ====

<code>
SOMEXTERN boolean somtisvoidSL(Entry *type, char *defn)
SOMEXTERN BOOL SOMLINK somtisvoidSL(Entry *type, char *defn)
</code>

Return TRUE if type%%->%%type is SOMTVoidBE it defn equal to "void", "VOID", "PMVOID".

Note: somtisvoid version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtreturnsStruct, somtreturnsStructSL function ====


==== somtreturnsPtr, somtreturnsPtrSL function ====


==== somtsimpleName, somtsimpleNameSL function ====


==== somtqualifyNames, somtqualifyNamesSL function ====


==== somtfindBaseEpNonPtr, somtfindBaseEpNonPtrSL function ====


==== somtprocessTraps, somtprocessTrapsSL function ====


==== somtallocMlist, somtallocMlistSL function ====


==== somtmlistend, somtmlistendSL function ====


==== somtisMutRef, somtisMutRefSL function ====


==== somtfreeMlist, somtfreeMlistSL function ====


==== somtdupMlist, somtdupMlistSL function ====


==== somtfreeWorld, somtfreeWorldSL function ====


==== somtinitMalloc, somtinitMallocSL function ====

<code>
SOMEXTERN void somtinitMalloc(BOOL dynamic)
SOMEXTERN void SOMLINK somtinitMallocSL(BOOL dynamic)
</code>

Initialize memory allocation/free functions.

Note: <dynamic> flag ignored in somFree version.

Note: somtinitMalloc version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtInitialiseEmitlib. somtInitialiseEmitlibSL function ====


==== somtInitialiseSmmeta, somtInitialiseSmmetaSL function ====


==== somtInitialiseCreatetc, somtInitialiseCreatetcSL function ====


==== somtInitialiseSmtypes, somtInitialiseSmtypesSL function ====


==== somtInitialiseSomc, somtInitialiseSomcSL function ====


==== somtInitialiseSmsmall, somtInitialiseSmsmallSL function ====


==== somtattMap, somtattMapSL function ====


==== somtexit, somtexitSL function ====


==== somtdymain, somtdymainSL function ====


==== somtaddHeader, somtaddHeaderSL function ====


==== somtnthArg, somtnthArgSL function ====


==== somtemitModule, somtemitModuleSL function ====

<code>
SOMEXTERN FILE * somtemitModule(char *file, Entry *cls, char *ext);
SOMEXTERN FILE * SOMLINK somtemitModuleSL(char *file, Entry *cls, char *ext);
</code>

Same as somtopenEmitFile.

Note: somtemitModule version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtallocDataList, somtallocDataListSL function ====


==== somtallocMethodList, somtallocMethodListSL function ====


==== somtclsfilename, somtclsfilenameSL function ====


==== somtclsname, somtclsnameSL function ====

<code>
SOMEXTERN char * somtclsname(Entry * cls);
SOMEXTERN char * SOMLINK somtclsnameSL(Entry * cls);
</code>

Return name of class <cls>.

Note: somclsname version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtfindMethodName, somtfindMethodNameSL function ====


==== somtfullPrototype, somtfullPrototypeSL function ====


==== somtfullTypedef, somtfullTypedefSL function ====


==== somtgetNonRepeatedParent, somtgetNonRepeatedParentSL function ====


==== somtgetatt, somtgetattSL function ====


==== somtgetdatt, somtgetdattSL function ====


==== somtgetAbistyle, somtgetAbistyleSL function ====

<code>
SOMEXTERN enum SOMTABIStyle  somtgetAbistyle( Entry * ep );
SOMEXTERN enum SOMTABIStyle  SOMLINK somtgetAbistyleSL( Entry * ep );
</code>

Return ABI style of Entry. At the current time returns always SOMTABIStyle_2

Note: somtgetABIStyle version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtimplicit, somtimplicitSL function ====


==== somtimplicitArgs, somtimplicitArgsSL function ====


==== somtincludeOnce, somtincludeOnceSL function ====

<code>
SOMEXTERN char * somtincludeOnceSL(Entry *cls, char *ext, char *buf);
SOMEXTERN char * SOMLINK somtincludeOnceSL(Entry *cls, char *ext, char *buf);
</code>

Return token to <buf> for once include checks using name of class <cls> and extension <ext> in form SOM_classname_ext.

Note: somtincludeOnce version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtpclsfilename, somtpclsfilenameSL function ====


==== somtpclsname, somtpclsnameSL function ====


==== somtprefixedPrototype, somtprefixedPrototypeSL function ====


==== somtreplaceDataName, somtreplaceDataNameSL function ====


==== somtrmSelf, somtrmSelfSL function ====


==== somtshortArgList, somtshortArgListSL function ====


==== somtimplicitMeta, somtimplicitMetaSL function ====


==== somtlistAttribute, somtlistAttributeSL function ====


==== somtnewMethodsCount, somtnewMethodsCountSL function ====


==== somtprivateMethodsCount, somtprivateMethodsCountSL function ====


==== somtaddHeader, somtaddHeaderSL function ====


==== somtcleanFiles, somtcleanFilesSL function ====

<code>
SOMEXTERN void somtcleanFiles(int status);
SOMEXTERN void  SOMLINK somtcleanFilesSL(int status);
</code>

Delete temporary files and exit.

Note: somtcleanFiles version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtdeclareIdlVarargs, somtdeclareIdlVarargsSL function ====


==== somtdymain. somtdymainSL function ====


==== somtemitModuleTypes, somtemitModuleTypesSL function ====


==== somtemitPassthru, somtemitPassthruSL function ====


==== somtfreeDataList, somtfreeDataListSL function ====


==== somtfreeMethodList, somtfreeMethodListSL function ====


==== somtfullComment, somtfullCommentSL function ====

<code>
SOMEXTERN void somtfullCommentSL(FILE * fp, char *fmt,...);
SOMEXTERN void SOMLINK somtfullCommentSL(FILE * fp, char *fmt,...);
</code>

Outout formatted string <fmt> to emitted file as comment using C-style comment via somtoidlComment function;

Note: somtfullComment version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somthandleDiskFull, somthandleDiskFullSL function ====


==== somtinitialiseMeta, somtinitialiseMetaSL function ====


==== somtoidlComment, somtoidlCommentSL function ====

<code>
SOMEXTERN void somtoidlComment(FILE * fp, int min, int max, char style, char *comment);
SOMEXTERN void  SOMLINK somtoidlCommentSL(FILE * fp, int min, int max, char style, char *comment);
</code>

Output oidl-<style> <comment> to file <fp> from colon <min> up to colon <max>.

Note: Seems IBM SOM ignores <max> value.

Style is one of following:

  * %%'/'%% - each line started from %%"//#"%%;
  * '#' - each line started from "#";
  * 'c' - C-style comment started from %%'/*'%% and ended with %%'*/'%%. each line started from %%"*"%%;
  * 's' -each line started from %%"--"%%;
  * 'd' - each line started from ";";
  * '+' - each line started from %%"//"%%;

Other values forced to 'c' style.

<comment> can contains at offset 0 0x01 signature indicating comment style. If style is zero the used style from comment position 1. Two first symbols of comment are ignored if style signature is present.

Note: somtoidlComment version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtscmsg, somtscmsgSL function ====


==== somtshortDefine, somtshortDefineSL function ====


==== somtuninitialiseMeta, somtuninitialiseMetaSL function ====


==== somtobseleteHeaderFile, somtobseleteHeaderFileSL function ====

<code>
SOMEXTERN FILE * somtobseleteHeaderFile(char *file, Entry *cls, char *ext, char *newext);
SOMEXTERN FILE * SOMLINK somtobseleteHeaderFileSL(char *file, Entry *cls, char *ext, char *newext);
</code>

Open emit file and write info about obsolete header. Return file pointer.

Note: somtoboleteHeaderFile version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtwidenType, somtwidenTypeSL function ====


==== somtgenAttStubs, somtgenAttStubsSL function ====


==== somtstrictidl, somtstrictidlSL function ====

<code>
SOMEXTERN void somtstrictidl(FILE *fp);
SOMEXTERN void SOMLINK somtstrictidlSL(FILE *fp);
</code>

Output definition of SOM_STRICT_IDL macro if somadd variable is TRUE;

Note: somtstrictidl version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

==== somtcreateTypeCodes, somtcreateTypeCodesSL function ====


==== somtemitTcConstant, somtemitTcConstantSL function ====


==== somtemitPredefinedTcConstants, somtemitPredefinedTcConstantsSL function ====


==== somtAncestorClass, somtAncestorClassSL function ====


==== somttcAlignment, somttcAlignmentSL function ====


==== somttcSize, somttcSizeSL function ====


==== somttcKind, somttcKindSL function ====


==== somttcSeqFromListString, somttcSeqFromListStringSL function ====


==== somtGetReintroducedMethods, somtGetReintroducedMethodsSL function ====


===== Symbol table support functions =====

===== somtallocBuf, somtallocBufSL function =====

Note: somtallocBuf version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtuniqString, somtuniqStringSL function =====

<code>
SOMEXTERN char * somtuniqString(MemBuf *membuf, char *s);
SOMEXTERN char * SOMLINK somtuniqStringSL(MemBuf *membuf, char *s);
</code>

Check is string unique and return NULL if not, or string itself if unique;

Note: somtuniqString version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtkeyword, somtkeywordSL function =====

<code>
SOMEXTERN long somtkeyword(KeytabEntry *keytab, char *kword, long keytabsize);
SOMEXTERN long SOMLINK somtkeywordSL(KeytabEntry *keytab, char *kword, long keytabsize);
</code>

Return token for keyword <kword> from keytaable <keytab> of <keytabsize> size.

Note: somtkeyword version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtaddEntry, somtaddEntrySL function =====

<code>
SOMEXTERN void * somtaddEntry(Stab *stab, char *name, void *ep);
SOMEXTERN void * SOMLINK somtaddEntrySL(Stab *stab, char *name, void *ep);
</code>

Add entry <ep> with name <name> to symbol table <stab>. Buffer for entry allocated by function.

Note: somtaddEntry version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtgetEntry, somtgetEntrySL function =====

<code>
SOMEXTERN void * somtgetEntry(Stab *stab, char *name);
SOMEXTERN void * SOMLINK somtgetEntrySL(Stab *stab, char *name);
</code>

Return pointer to entry structure with name equal to <name> from symbol table <stab>

Note: somtgetEntry version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtstabFirst, somtstabFirstSL function =====

<code>
SOMEXTERN void * somtstabFirst(Stab *stab, Sep **sepp);
SOMEXTERN void * SOMLINK somtstabFirstSL(Stab *stab, Sep **sepp);
</code>

Return first entry from symbol table <stab> and, optionally, returns sep entry in <sepp>.

Note: somtstabFirst version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtstabNext, somtstabNextSL function =====

<code>
SOMEXTERN void * somtstabNext(Stab *stab, Sep **sepp);
SOMEXTERN void * SOMLINK somtstabNextSL(Stab *stab, Sep **sepp);
</code>

Return next after last search entry from symbol table <stab> and, optionally, returns sep entry in <sepp>.

Note: somtstabNext version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtstabFirstName, somtstabFirstNameSL function =====

<code>
SOMEXTERN void * somtstabFirstName(Stab *stab, char *name, Sep **sepp);
SOMEXTERN void * SOMLINK somtstabFirstNameSL(Stab *stab, char *name, Sep **sepp);
</code>

Return first entry with <name> from symbol table <stab> and, optionally, returns sep entry in <sepp>.

Note: somtstabFirstName version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtstabNextName, somtstabNextNameSL function =====

<code>
SOMEXTERN void * somtstabNextName(Stab *stab, Sep **sepp);
SOMEXTERN void * SOMLINK somtstabNextNameSL(Stab *stab, Sep **sepp);
</code>

Return next after last search entry from symbol table <stab> and, optionally, returns sep entry in <sepp>.

Note: somtstabNextName version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtcreateMemBuf, somtcreateMemBufSL function =====

Note: somtcreateMemBuf version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtcreateStab, somtcreateStabSL function =====

<code>
SOMEXTERN void somtcreateStab(Stab *stab, long stabsize, long entrysize);
SOMEXTERN void SOMLINK somtcreateStabSL(Stab *stab, long stabsize, long entrysize);
</code>

Initialize symbol table structure <stab> using hash index size <stabsize> and entry size <entrysize>.

Note: somtcreateStab version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somticstrcmp, somticstrcmpSL function =====

<code>
SOMEXTERN int somticstrcmp(char *s, char *t)
SOMEXTERN int SOMLINK somticstrcmpSL(char *s, char *t);
</code>

Alias of C stricmp.

Note: somticstrcmp version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtaddEntryBuf, somtaddEntryBufSL function =====

<code>
SOMEXTERN void * somtaddEntryBuf(Stab *stab, char *name, void *ep, void *buf, size_t len);
SOMEXTERN void * SOMLINK somtaddEntryBufSL(Stab *stab, char *name, void *ep, void *buf, size_t len);
</code>

Add entry <ep> with name <name> to symbol table <stab> to buffer <buf> with size <len>

Note: somtaddEntryBuf version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== somtfreeStab, somtfreeStabSL function =====

Note: somtfreeStab version uses default compiler calling convention. For IBM SOM 3.0 for NT it is Optlink.

===== 3. SOM Emitter Framework =====

==== SOMTAttributeEntryC Class ====


=== somtGetFirst<Item> Methods ===


=== somtGetNext<Item> Methods ===


==== SOMTBaseClassEntryC Class ====


==== SOMTClassEntryC Class ====


=== somtFilterNew Method ===


=== somtFilterOverridden Method ===


=== somtGetFirst<Item> Methods ===


=== somtGetNext<Item> Methods ===


=== somtGetReleaseNameList Method ===


==== SOMTCommonEntryC Class ====


=== somtGetFirstArrayDimension Method ===


=== somtGetNextArrayDimension Method ===


=== somtIsArray Method ===


=== somtIsPointer Method ===


==== SOMTConstEntryC Class ====


==== SOMTDataEntryC Class ====


==== SOMTEmitC Class ====


=== somtAll Method ===


=== somtEmit<Section> Methods ===


=== somtEmitFullPassthru Method ===


=== somtFileSymbols Method ===


=== somtGenerateSections Method ===


=== somtGetFirstGlobalDefinition Method ===


=== somtGetGlobalModifierValue Method ===


=== somtGetNextGlobalDefinition Method ===


=== somtImplemented Method ===


=== somtInherited Method ===


=== somtNew Method ===


=== somtNewNoProc Method ===


=== somtNewProc Method ===


=== somtOpenSymbolsFile Method ===


=== somtOverridden Method ===


=== somtScan<Section> Methods ===


=== somtSetPredefinedSymbols Method ===


=== somtVA Method ===


==== SOMTEntryC Class ====


=== somtFormatModifier Method ===


=== somtGetFirstModifier Method ===


=== somtGetModifierList Method ===


=== somtGetModifierValue Method ===


=== somtGetNextModifier Method ===


=== somtSetSymbolsOnEntry Method ===


==== SOMTEnumEntryC Class ====


=== somtGetFirstEnumName Method ===


=== somtGetNextEnumName Method ===


==== SOMTEnumNameEntryC Class ====

==== SOMTMetaClassEntryC Class ====


==== SOMTMethodEntryC Class ====


=== somtGetFirst<Item> Methods ===


=== somtGetFullCParamList Method ===


=== somtGetFullParamNameList Method ===


=== somtGetIDLParamList Method ===


=== somtGetNext<Item> Methods ===


=== somtGetNthParameter Method ===


=== somtGetShortCParamList Method ===


=== somtGetShortParamNameList Method ===


==== SOMTModuleEntryC Class ====


=== somtGetFirst<Item> Methods ===


=== somtGetNext<Item> Methods ===


==== SOMTParameterEntryC Class ====


==== SOMTPassthruEntryC Class ====


=== somtIsBeforePassthru Method ===


==== SOMTSequenceEntryC Class ====


==== SOMTStringEntryC Class ====


==== SOMTStructEntryC Class ====


=== somtGetFirstMember Method ===


=== somtGetNextMember Method ===


==== SOMTTemplateOutputC Class ====


=== somtAddSectionDefinitions Method ===

<code>
void somtAddSectionDefinitions(in string defString);
</code>

Add section definitions from <defString> buffer to Symbol table.

=== somtCommentStyle attribute ===

<code>
attribute somtCommentStyleT somtCommentStyle;
</code>

Set style of output comment. Supported styles are:

  * somtDashesE: "--" at the start of each line
  * somtCPPE: C++ style, %%"//"%% at the start of each line
  * somtCSimpleE: simple C style, each line wrapped in %%/*%% and %%*/%%
  * somtCBlockE: block C style, block style, ie leading %%/*%% then a * on each line and then a final %%*/%%
  * somtPSimpleE: simple Pascal style, each line wrapped in (* and *)
  * somtPBlockE: block Pascal style, block style, ie leading (* then a * on each line and then a final *)
  * somtPBorlandE: block Borland Pascal style, block style, ie leading { and then a final }

=== somtLineLength attribute ===

<code>
attribute long somtLineLength;
</code>

Line length limit. At least on list item will be output.

=== somtCommentNewline attribute ===

<code>
attribute boolean somtCommentNewline;
</code>

Output comment block from new line flag.
=== somtCheckSymbol Method ===

<code>
boolean somtCheckSymbol(in string name);
</code>

Return TRUE id symbol <name> exists in Symbol Table.

=== somtExpandSymbol Method ===

<code>
string somtExpandSymbol(in string s, in string buf);
</code>

=== somtGetSymbol Method ===

<code>
string somtGetSymbol(in string name);
</code>

Return symbol value for <name> from Symbol table.

=== somto Method ===

<code>
void somto(in string tmplt);
</code>

Outputs a template, <tmplt>, after substitution for any symbols that occur in it. Five substitutions are supported: simple, list, comment, tab, and conditional.

Substitutable items in the template are bracketed with angle brackets. (Backslash can be used to escape an angle bracket.)

Simple substitutions just replace a symbol with its value. If the symbol has no value in this template object then the symbol is replaced error string but no error is raised.

List substitution assumes that the symbol has a value in output template list form. This is a newline separated string of values. The list substitution specification consists of four parts, a prefix, a symbol, a separator, and a list indicator. prefixes and separators can only be composed of blanks, comma, colons, and semi-colons.  The list indicator is "..." (three periods).  For example, the list substitution specification "<, name, ...> has a prefix of ", ", a symbol of "name" and a separator of ", ".  The prefix will be used whenever there is at least one item in the list and the separator will be used between any two list items.  After the first items of a list is placed each additional item is evaluated to see if it would begin after the line length limit (set by _set_somtLineLength), if it would then a new line is begun and the value is placed directly under the first item.
Comment substitution assumes that the symbol has a value in output template list form.  A comment specification consists of a comment indicator followed by a symbol name. The comment indicator is "--".  Eg, %%<--%% classComment> is a valid comment substitution specification.  The lines of the comment are output according to the current comment style (see <somtCommentStyle>) and aligned with the starting column of the comment specification.
Tab substitution is specified by <@dd> where "dd" is a valid positive integer. Blanks will be inserted into the output stream if necessary to position the next character of output at the column indicated by "dd".

Conditional substitution is specified by putting a question mark, "?", in column one of the template line.  The line will not be output at all unless at least one valid, non-blank,  symbol substitution  occurs on the line.

Note: Due design error in IBM SOM 3.0 this method can't be fully replaced. You can do some preprocessing of <templ> and call parent method. This is due direct usage of FILE structure in somto method. This means you can't write to file using standard C file functions because FILE structure is a compiler depended. But you don't know which compiler was used for. Header files contains compiler-independed file functions (somtok*), but no any of this functions, except two ones, exported in SOM DLLs. So, if you want to fully replace this method then you need also replace lot of other methods and functions of Emitter Framework and SOM Compiler library. For IBM SOM 2.1 all seems to be ok, but you must use somtok* functions from SOMC.DLL, not standard C runtime for file operations.

=== somtOutputComment Method ===

<code>
void somtOutputComment(in string comment);
</code>

Outputs comment using comment style settings.

Note: Due design error in IBM SOM 3.0 this method can't be fully replaced. You can do some preprocessing of <comment> and call parent or somto method. This is due direct usage of FILE structure in somto method. This means you can't write to file using standard C file functions because FILE structure is a compiler depended. But you don't know which compiler was used for. Header files contains compiler-independed file functions (somtok*), but no any of this functions, except two ones, exported in SOM DLLs. So, if you want to fully replace this method then you need also replace lot of other methods and functions of Emitter Framework and SOM Compiler library. For IBM SOM 2.1 all seems to be ok, but you must use somtok* functions from SOMC.DLL, not standard C runtime for file operations.

=== somtOutputSection Method ===

<code>
void somtOutputSection(in string sectionName);
</code>

Same as somto method, but template read from Symbol table with key equal to sectionName. Uses somto method for actual output.

=== somtReadSectionDefinitions Method ===

<code>
void somtReadSectionDefinitions(inout FILE fp);
</code>

This method reads sections from template file and stores them in Symbol table. fp is a value returned by somtOpenSymbolsFile method of SOMTEmitC class.

Note: Due design error in IBM SOM 3.0 this method can't be replaced. This is due unknown structure of FILE type. This means you can't read file using standard C file functions because FILE structure is a compiler depended. But you don't know which compiler was used for. Header files contains compiler-independed file functions (somtok*), but no any of this functions, except two ones, exported in SOM DLLs. So, if you want to fully replace this method then you need also replace lot of other methods and functions of Emitter Framework and SOM Compiler library. For IBM SOM 2.1 all seems to be ok, but you must use somtok* functions from SOMC.DLL, not standard C runtime for file operations.

=== somtSetOutputFile Method ===

<code>
void somtSetOutputFile(inout FILE fp);
</code>

Pass FILE structure to object to use for file I/O. fp is a value returned by somtOpenEmitFile or somtOpenEmitFileSL.

Note: FILE structure must be same as in other I/O methods and functions.

=== somtSetSymbol Method ===

<code>
void somtSetSymbol(in string name, in string value);
</code>

Set symbol name in Symbol table to value. name and value must be allocated using SOMMaloc function. It will be deallocated using SOMFree on object destroying.

=== somtSetSymbolCopyBoth Method ===

<code>
void somtSetSymbolCopyBoth(in string name, in string value);
</code>

Same as somtSetSymbol but name and value will be copied to internally allocated buffer.

=== somtSetSymbolCopyName Method ===

<code>
void somtSetSymbolCopyName(in string name, in string value);
</code>

Same as somtSetSymbol but name will be copied to internally allocated buffer.

=== somtSetSymbolCopyValue Method ===

<code>
void somtSetSymbolCopyValue(in string name, in string value);
</code>

Same as somtSetSymbol but value will be copied to internally allocated buffer.

==== SOMTTypedefEntryC Class ====


=== somtGetFirstDeclarator Method ===


=== somtGetNextDeclarator Method ===


==== SOMTUnionEntryC Class ====


=== somtGetFirstCaseEntry Method ===


=== somtGetNextCaseEntry Method ===


==== SOMTUserDefinedTypeEntryC Class ====


==== SOMStringTableC Class ====

<code>
interface SOMStringTableC : SOMObject
</code>

Объектами класса SOMStringTableC являются символьные таблицы, которые отображают строки на строки (ключ-значение, ассоциативные массивы). Любой экземпляр класса  может хранить неограниченное число элементов. При увеличении количества строк время поиска строки увеличивается. В отличие от IBM SOM в данной реализации не используются хэш-таблицы.

=== somstTargetCapacity attribute ===

<code>
attribute unsigned long somstTargetCapacity;
</code>

Емкость ассоциативного массива. Значение не влияет на работу и сохранено для совместимости. В IBM SOM данный атрибут определял размер хэш-таблицы. Данный атрибут должен выставляться до вызова любого из методов данного класса

=== somstAssociationsCount attribute ===

<code>
readonly attribute unsigned long somstAssociationsCount;
</code>

Текущее число ассоциаций в массиве

=== somstAssociate method ===

<code>
short somstAssociate(in string key, in string value);
</code>

Устанавливает связь <key> и <value>. Возвращает 0, если связь не может быть установлена (<key> нулевой или недостаточно памяти); -1 - ассоциация успешна выполнена, но <key> уже имел значение до вызова метода, 1 - ассоциация успешно выполнена и <key> не существовал. Замечание: массив сохраняет ссылки на <key> и <value>, передаваемые в аргументах. Копия значений <key> и <value> не создается. При уничтожении объекта память, занимаемая <key> и <value> освобождается с помощью SOMFree, т.е. память под <key> и <value> должна быть выделена с помощью SOMMalloc и аналогичных функций. Замечание: При замене <value> при имеющемся <key> старое <value> заменаяется, память не освобождается

=== somstAssociateCopyKey method ===

<code>
short somstAssociateCopyKey(in string key, in string value);
</code>

То же, что и <somstAssociate>, но массив содержит копии значений <key>. Значение <key> копируется в выделяемую с помощью SOMMalloc память.

=== somstAssociateCopyValue method ===

<code>
short somstAssociateCopyValue(in string key, in string value);
</code>

То же, что и <somstAssociate>, но массив содержит копии значений <value>. Значение <value> копируется в выделяемую с помощью SOMMalloc память.

=== somstAssociateCopyBoth method ===

<code>
short somstAssociateCopyBoth(in string key, in string value);
</code>

То же, что и <somstAssociate>, но массив содержит копии значений <key> и <value>. Значения <key> и <value> копируются в выделяемую с помощью SOMMalloc память.

=== somstGetAssociation method ===

<code>
string somstGetAssociation(in string key);
</code>

Возвращается строка, ассоциированная с <key>, или NULL, если нет ассоциации. Массив продолжает хранить указатель на значение.

=== somstClearAssociation method ===

<code>
boolean somstClearAssociation(in string key);
</code>

The association for <key>, if any, is removed.1 is returned if <key> had an association, and 0 is returned if it did not.

=== somstGetIthKey method ===

<code>
string somstGetIthKey(in unsigned long i);
</code>

Возвращает ключевую часть <i>-й по счету ассоциации. Если нет ассоциации, то возвращает NULL. Порядок ассоциации в массиве не определен, но остается постоянным до следующей модификации.

=== somstGetIthValue method ===

<code>
string somstGetIthValue(in unsigned long i);
</code>

Возвращает значимую часть <i>-й по счету ассоциации. Если нет ассоциации, то возвращает NULL. Порядок ассоциации в массиве не определен, но остается постоянным до следующей модификации.

==== somtStrDup function ====

<code>
SOMEXTERN char * SOMLINK somtStrDup(char *str);
</code>

Allocate memory and duplicate string str

==== somtEntryTypeName function ====

<code>
SOMEXTERN char * SOMLINK somtEntryTypeName(SOMTTypes type);
</code>

Return string representation of type of Entry structure except special case SOMTEmitterBeginE and SOMTEmitterEndE types.

==== somtShowEntry function ====

<code>
SOMEXTERN void SOMLINK somtShowEntry(Entry * ep);
</code>

Output using somPrintf information about Entry structure.

==== somtStrCat function ====

<code>
SOMEXTERN char * SOMLINK somtStrCat(int count,...);
</code>

Concatenate count of strings.

==== somtMakeIncludeStr function ====

<code>
SOMEXTERN char * SOMLINK somtMakeIncludeStr(boolean local, char *stem, char *suffix);
</code>

Produce include string for local (include "") or global (include <>) using file stem as file name and suffix as file extension.

==== somtNewSymbol function ====

<code>
SOMEXTERN char * SOMLINK somtNewSymbol(char *prefix, char *stem);
</code>

Allocate memory and produce string from prefix and stem.

==== somtGetFileStem function ====

<code>
SOMEXTERN char * SOMLINK somtGetFileStem(char *fullName);
</code>

Allocate memory and return file stem from file name.

==== somtGetObjectWrapper function ====

<code>
SOMEXTERN SOMTEntryC * SOMLINK somtGetObjectWrapper(Entry * ep);
</code>

Return SOMT*EntryC object for ep Entry structure.

Mapping of Entry types to SOMT*EntryC classes:

^ Entry type  ^ Emitter Framework Class ^
| SOMTArgumentE | SOMTParameterEntryC |
| SOMTAttE | SOMTAttributeEntryC |
| SOMTBadEntryE | Fatal error |
| SOMTBaseE | SOMTBaseClassEntryC |
| SOMTClassE | SOMTClassEntryC |
| SOMTConstE | SOMTConstEntryC |
| SOMTDataE | SOMTDataEntryC |
| SOMTEnumBE | SOMTEnumNameEntryC |
| SOMTEnumE | SOMTEnumEntryC |
| SOMTEnumPE | SOMTEnumEntryC |
| SOMTFloatBE | SOMTEntryC |
| SOMTAnyBE | SOMTEntryC |
| SOMTGroupE | SOMTEntryC |
| SOMTCopyrightE | SOMTEntryC |
| SOMTLongBE | SOMTEntryC |
| SOMTNegativeBE | SOMTEntryC |
| SOMTOctetBE | SOMTEntryC |
| SOMTTypeCodeBE | SOMTEntryC |
| SOMTBooleanBE | SOMTEntryC |
| SOMTCaseEntryE | SOMTEntryC |
| SOMTCaseListE | SOMTEntryC |
| SOMTCaseSTME | SOMTEntryC |
| SOMTCharBE | SOMTEntryC |
| SOMTDclListE | SOMTEntryC |
| SOMTDefaultE | SOMTEntryC |
| SOMTDoubleBE | SOMTEntryC |
| SOMTEBaseE | SOMTEntryC |
| SOMTEEnumE | SOMTEntryC |
| SOMTShortBE | SOMTEntryC |
| SOMTStringBE | SOMTEntryC |
| SOMTUnsignedLongBE | SOMTEntryC |
| SOMTUnsignedShortBE | SOMTEntryC |
| SOMTVoidBE | SOMTEntryC |
| SOMTVoidPtrBE | SOMTEntryC |
| SOMTMetaE | SOMTMetaClassEntryC |
| SOMTModuleE | SOMTModuleEntryC |
| SOMTNewMethodE | SOMTMethodEntryC |
| SOMTOverriddenMethodE | SOMTMethodEntryC |
| SOMTOverrideMethodE | SOMTMethodEntryC |
| SOMTPassthruE | SOMTPassthruEntryC |
| SOMTSequenceE | SOMTSequenceEntryC |
| SOMTSequenceTDE | SOMTSequenceEntryC |
| SOMTStringE | SOMTStringEntryC |
| SOMTStructE | SOMTStructEntryC |
| SOMTStructPE | SOMTStructEntryC |
| SOMTStructSE | SOMTStructEntryC |
| SOMTTyDclE | SOMTTypedefEntryC |
| SOMTTypedefE | SOMTTypedefEntryC |
| SOMTTypedefBE | SOMTUserDefinedTypeEntryC |
| SOMTUnionE | SOMTUnionEntryC |
| SOMTUnionPE | SOMTUnionEntryC |
| SOMTUnionSE | SOMTUnionEntryC |
| SOMTEmitterBeginE | Fatal error |
| SOMTEmitterEndE | Fatal error |

====== IV. Appendixes ======

===== 1. Appendix 1. SOM ABI =====

Due switching from MSVC (IBM SOM 2.1) to VAC (IBM SOM 3.0) some problems was occur:

First problem is a calling convention. All non SOMLINK calls in IBM SOM 2.1 is a _cdecl calls. But under IBM SOM 3.0 all non SOMLINK calls is a Optlink calls. Read some info here:
https://github.com/prokushev/SOM-Delphi-Wiki/blob/master/Known%20differences%20between%20SOM%202.1%20and%20SOM%203.0.md
Goal of somFree SOM Compiler and Emitter Framework is to provide a possibility to use original IBM SOM emitters as from  IBM SOM 2.1 as from IBM SOM 3.0. Another goal is a development of somFree emitters, which can be used on both IBM SOM 2.1 and IBM SOM 3.0 compilers.To achieve above goals somFree provides some solutions:
1. Automatic somc.dll calling convention switching.
somFree SOMC.DLL provides automatic switching of IBM SOM 2.1 ABI and IBM SOM 3.0 ABI. Switching occurs on somtload call during loading of emitter. For IBM SOM 3.0 all emitter contains entry point emitSL, so, if loading was success, then somFree handles Optlink calling convention for all non SOMLINK calls. If no such entry (found only emit) then IBM SOM 2.1 ABI used.
2. Support both entry points (emitSL and emit) in emitters.
somFree emitters automatically switches to IBM SOM 2.1 ABI on emit call and to IBM SOM 3.0 ABI on emitSL call.
====== Список литературы ======


[1] 	Object Management Group, «C Langue Mapping Specification 1.0,» [В Интернете]. Available: https://www.omg.org/spec/C/. [Дата обращения: 24 Август 2022].
[2] 	IBM, OS/2 2.0 Technical Library. System Object Model Guide and Reference. First Edition., 1991. 





